import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;

import java.io.FileReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CsvUtil {
    public static List<Map<String, String>> parseCsvToMap(String filePath, char delimiter) throws Exception {
        List<Map<String, String>> records = new ArrayList<>();
        try (Reader reader = new FileReader(filePath)) {
            CSVParser parser = CSVFormat.DEFAULT
                .withFirstRecordAsHeader()
                .withDelimiter(delimiter)
                .parse(reader);

            for (CSVRecord csvRecord : parser) {
                records.add(csvRecord.toMap());
            }
        }
        return records;
    }
}


***************************************************************

public void processRCAttestationUpload(String filePath, String scheduleId) throws Exception {
    List<Map<String, String>> allRecords = CsvUtil.parseCsvToMap(filePath, '|');
    List<Map<String, Object>> validRecords = new ArrayList<>();

    // Choose/filter, transform as needed
    for (Map<String, String> record : allRecords) {
        String fullKey = record.get("FULLKEY");
        if (fullKey != null && !fullKey.trim().isEmpty()) {
            Map<String, Object> mappedRecord = Map.of(
                "SCHEDULEID", scheduleId,
                "FULLKEY", fullKey,
                "AGREED_FLAG", record.getOrDefault("RC_CHECKER_STATUS", "").toUpperCase(),
                "CREATE_DT", java.sql.Date.valueOf(java.time.LocalDate.now())
            );
            validRecords.add(mappedRecord);
        }
    }

    // Now use batch DAO, mapping each record to its SQL parameters
    String sql = "INSERT INTO RCN_UPLDETAILS (SCHEDULEID, FULLKEY, AGREED_FLAG, CREATE_DT) VALUES (?, ?, ?, ?)";
    batchDAO.batchInsert(sql, validRecords, (ps, rec) -> {
        ps.setString(1, (String) rec.get("SCHEDULEID"));
        ps.setString(2, (String) rec.get("FULLKEY"));
        ps.setString(3, (String) rec.get("AGREED_FLAG"));
        ps.setDate(4, (java.sql.Date) rec.get("CREATE_DT"));
    });
}

**************************************

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

@Repository
public class GenericBatchDAOImpl implements GenericBatchDAO {
    
    private final JdbcTemplate jdbcTemplate;
    
    public GenericBatchDAOImpl(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    @Override
    public <T> int[] batchInsert(String sql, List<T> entities, 
                                ParameterSetter<T> parameterSetter) {
        return batchInsert(sql, entities, parameterSetter, entities.size());
    }
    
    @Override
    public <T> int[] batchInsert(String sql, List<T> entities, 
                                ParameterSetter<T> parameterSetter, int batchSize) {
        if (entities.isEmpty()) {
            return new int[0];
        }
        
        // Use Spring's batching with custom batch size
        int[][] results = jdbcTemplate.batchUpdate(
            sql,
            entities,
            batchSize,
            new ParameterizedPreparedStatementSetter<T>() {
                @Override
                public void setValues(PreparedStatement ps, T entity) throws SQLException {
                    parameterSetter.setParameters(ps, entity);
                }
            }
        );
        
        // Flatten the 2D array to 1D for simpler return type
        return flattenResults(results);
    }
    
    private int[] flattenResults(int[][] results) {
        int totalLength = 0;
        for (int[] batch : results) {
            totalLength += batch.length;
        }
        
        int[] flattened = new int[totalLength];
        int index = 0;
        for (int[] batch : results) {
            System.arraycopy(batch, 0, flattened, index, batch.length);
            index += batch.length;
        }
        return flattened;
    }
}
